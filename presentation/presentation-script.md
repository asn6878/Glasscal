# Glasscal 개발 과정 발표 대본

> 이 대본은 `development-presentation.md` 발표자료를 보여주면서 진행합니다.

---

## 발표 시작 전 준비사항

- [ ] 발표자료 PDF로 변환 (Markdown → PDF)
- [ ] 프로젝터/화면 연결 확인
- [ ] 노트북 배터리 및 전원 확인
- [ ] 코드 스크린샷 준비
- [ ] 백업 USB 준비

---

## 도입부 (0:00 - 1:00)

### [슬라이드 1: 타이틀]

안녕하세요. 오늘은 제가 개발한 **Glasscal**이라는 Android 캘린더 애플리케이션의 개발 과정과 기술적 고민들을 공유하고자 합니다.

*[잠시 멈춤]*

Glasscal은 **글래스모피즘**, 즉 유리 같은 반투명한 디자인을 적용한 일정 관리 앱입니다.

단순히 기능만 구현하는 것이 아니라, 사용자에게 **시각적으로 즐거운 경험**을 제공하는 것을 목표로 했습니다.

---

## 1부: 프로젝트 개요 (1:00 - 3:00)

### [슬라이드 2: 프로젝트 개요]

먼저 프로젝트의 전반적인 내용을 소개하겠습니다.

*[1.1 프로젝트 소개 부분 가리키기]*

Glasscal은 약 **2-3주** 동안 개발한 개인 프로젝트입니다.
Android SDK 24 이상, 즉 Android 7.0 Nougat 이상의 기기에서 동작합니다.

*[1.2 개발 동기 부분으로 이동]*

이 프로젝트를 시작한 이유는 크게 네 가지입니다.

**첫째**, 기존 캘린더 앱들의 단조로운 디자인에서 벗어나 **시각적으로 아름다운 UI**를 만들고 싶었습니다.

**둘째**, 최신 디자인 트렌드인 **글래스모피즘**을 직접 구현해보고 싶었습니다.

**셋째**, 오프라인에서도 잘 작동하면서 필요할 때 클라우드 동기화가 가능한 **하이브리드 방식**을 경험하고 싶었습니다.

**마지막으로**, Android 네이티브 개발 역량을 더욱 강화하고 싶었습니다.

*[1.3 프로젝트 목표 부분]*

목표는 간단명료합니다.
유리처럼 투명하고 우아한 UI, 직관적인 일정 관리 기능, 그리고 부드러운 애니메이션을 제공하는 것이었습니다.

---

## 2부: 기술 스택 (3:00 - 4:30)

### [슬라이드 3: 기술 스택]

사용한 기술 스택을 살펴보겠습니다.

*[2.1 개발 환경 테이블 가리키기]*

개발 언어는 **Kotlin**을 사용했고, Android Studio에서 개발했습니다.

*[2.2 핵심 라이브러리로 이동]*

핵심 라이브러리를 카테고리별로 나누어 보면...

**UI와 디자인** 부분에서는 **BlurView**가 가장 중요합니다.
이것이 바로 글래스모피즘의 핵심인 블러 효과를 구현해주는 라이브러리입니다.
Coil은 이미지 로딩과 캐싱을 담당합니다.

**아키텍처와 데이터** 측면에서는 **Room Database**로 로컬 데이터를 저장하고,
**ViewModel과 LiveData**를 사용해서 MVVM 패턴을 구현했습니다.
비동기 처리는 **Kotlin Coroutines**와 **Flow**로 처리했습니다.

**네트워크** 부분은 **Retrofit**을 사용해서 REST API와 통신합니다.

이런 라이브러리들이 모여서 하나의 완성된 앱을 만들어냈습니다.

---

## 3부: 주요 기능 (4:30 - 5:30)

### [슬라이드 4: 주요 기능]

*[3.1 기능 목록 테이블 보여주기]*

구현된 주요 기능들입니다. 모두 체크 표시가 되어 있죠.

월간 캘린더 뷰, 할일 관리, 이미지 첨부, 클라우드 동기화 등이 있고,
무엇보다 **글래스모피즘 디자인**과 **부드러운 애니메이션**이 이 앱의 핵심입니다.

*[3.2 화면 구성 다이어그램 가리키기]*

화면 구성은 이렇게 계층 구조로 되어 있습니다.

메인 Activity 아래에 **CalendarFragment**가 있고,
날짜를 클릭하면 **TaskListBottomSheet**가 올라오고,
거기서 다시 **AddTaskBottomSheet**로 할일을 추가하거나 수정합니다.

이런 계층적 구조 덕분에 사용자는 컨텍스트를 잃지 않으면서 작업을 진행할 수 있습니다.

---

## 4부: 기술적 고민 (5:30 - 12:00)

### [슬라이드 5: 글래스모피즘 디자인 구현]

이제 가장 중요한 부분인 **기술적 고민과 해결 방법**에 대해 이야기하겠습니다.

#### 글래스모피즘 구현 (5:30 - 7:30)

*[4.1 제목 가리키기]*

첫 번째 고민은 "**어떻게 진짜 유리처럼 보이게 만들까?**"였습니다.

처음에는 단순히 투명도만 조절하면 될 줄 알았습니다.
하지만 그렇게 하니까 그냥 투명한 상자일 뿐, 유리 느낌이 전혀 나지 않았습니다.

*[코드 부분 가리키기]*

연구 끝에 찾은 해결책은 **BlurView 라이브러리**를 사용하는 것이었습니다.

이 코드를 보시면, BlurView를 설정하는 부분입니다.
`setupWith`로 뷰를 연결하고, `RenderScriptBlur`로 블러 알고리즘을 지정합니다.
`setBlurRadius(20f)`로 블러 강도를 조절하고,
`setBlurAutoUpdate(true)`로 배경이 변할 때마다 자동으로 블러를 업데이트합니다.

*[계층 구조 다이어그램 가리키기]*

계층 구조는 이렇게 3단계입니다.

1. 맨 밑에 **배경 이미지나 그라디언트**
2. 그 위에 **블러 뷰**가 배경을 흐리게 만들고
3. 맨 위에 **콘텐츠**가 표시됩니다.

*[XML 코드 부분]*

실제 drawable 파일을 보시면, 레이어를 두 개 쌓았습니다.

첫 번째 레이어는 **그림자**입니다. 파란색에 20% 불투명도를 줘서 입체감을 만듭니다.

두 번째 레이어는 **그라디언트**입니다.
위쪽은 50% 흰색, 아래쪽은 20% 흰색으로 점점 투명해지는 효과를 줍니다.
그리고 1.5dp 두께의 밝은 테두리를 추가했습니다.

*[색상 코드 부분]*

처음에는 배경을 노란색/오렌지 톤으로 했었는데, 유리 느낌이 전혀 나지 않았습니다.
여러 번의 시도 끝에 **파란색 → 보라색 → 인디고** 계열로 변경했고,
그제야 자연스러운 밝은 톤이 나왔습니다.

결과적으로 실시간 블러 효과로 진짜 유리 같은 느낌을 구현했고,
일관된 디자인 시스템을 만들 수 있었습니다.

---

### [슬라이드 6: Bottom Sheet 선택 이유]

#### Bottom Sheet 선택 (7:30 - 9:00)

*[4.2 제목 가리키기]*

두 번째 고민은 "**할일 목록을 어떻게 보여줄까?**"였습니다.

*[옵션 리스트 가리키기]*

세 가지 옵션을 고려했습니다.

**첫째, 새로운 Activity**를 여는 방법.
하지만 이건 화면 전환이 부담스럽고, 사용자가 어느 날짜를 보고 있는지 컨텍스트를 잃게 됩니다.

**둘째, Dialog**를 사용하는 방법.
작은 화면에서는 답답하고, 콘텐츠가 많을 때 스크롤이 불편합니다.

**셋째, Bottom Sheet**.
이게 바로 제가 선택한 방법입니다.
모달 UI이면서 컨텍스트를 유지하고, 자연스러운 사용자 경험을 제공합니다.

*[코드 부분 가리키기]*

코드를 보시면, BottomSheetDialogFragment를 상속받아서 구현했습니다.

중요한 부분은 `setupBottomSheetBehavior`인데요,
`STATE_EXPANDED`로 설정해서 완전히 펼쳐진 상태로 시작하고,
`skipCollapsed`를 true로 해서 중간 상태를 건너뛰도록 했습니다.

*[장점 리스트 가리키기]*

Bottom Sheet의 장점을 정리하면:

1. **컨텍스트 유지**: 뒤에 캘린더가 보여서 어느 날짜인지 바로 알 수 있고
2. **자연스러운 애니메이션**: 하단에서 슬라이드 업되면서 부드럽게 나타나고
3. **제스처 지원**: 아래로 스와이프하면 닫히고
4. **유연한 높이**: 콘텐츠에 따라 자동으로 높이가 조절됩니다.

결과적으로 Material Design 가이드라인을 준수하면서 직관적인 UX를 구현했습니다.

---

### [슬라이드 7: 이미지와 데이터 로컬 저장]

#### 이미지 저장 방식 (9:00 - 10:30)

*[4.3 제목 가리키기]*

세 번째 고민은 "**이미지를 어떻게 저장하고 관리할까?**"였습니다.

*[옵션 리스트]*

세 가지 방법을 고려했습니다.

**첫째, Base64 인코딩**해서 데이터베이스에 저장.
하지만 이러면 DB 크기가 급증하고 성능이 저하됩니다.

**둘째, 내부 저장소에 복사**.
이것도 이미지가 중복 저장되어 용량을 낭비합니다.

**셋째, Content URI 사용**.
이게 제가 선택한 방법입니다. 원본을 참조만 하기 때문에 효율적입니다.

*[Entity 코드 가리키기]*

Room Database의 Task Entity를 보시면,
`imageUri`를 String으로 저장합니다. URI를 텍스트로 저장하는 거죠.

*[Persistable Permission 코드]*

핵심은 **Persistable URI Permission**을 획득하는 겁니다.

일반적인 이미지 선택은 임시 권한만 부여되어서 앱을 재시작하면 권한이 사라집니다.
하지만 `takePersistableUriPermission`을 호출하면 **영구 권한**을 얻을 수 있습니다.

*[ACTION_OPEN_DOCUMENT 설명]*

그래서 `ACTION_GET_CONTENT` 대신 `ACTION_OPEN_DOCUMENT`를 사용했습니다.
이렇게 하면 영구 권한을 부여받을 수 있고, 앱 재시작 후에도 이미지가 유지됩니다.

*[Coil 코드]*

이미지 로딩은 Coil 라이브러리로 최적화했습니다.
크로스페이드 효과도 주고, BlurView와의 호환을 위해 하드웨어 가속을 비활성화했습니다.

결과적으로 메모리 효율적이고, 빠른 로딩 속도를 달성했습니다.

---

### [슬라이드 8: 월 변경 애니메이션]

#### 애니메이션 구현 (10:30 - 11:30)

*[4.4 제목 가리키기]*

네 번째 고민은 "**월이 바뀔 때 어떻게 부드럽게 전환할까?**"였습니다.

단순히 데이터만 교체하면 갑작스럽게 바뀌어서 사용자 경험이 좋지 않습니다.

*[XML 애니메이션 코드]*

해결책은 **리소스 애니메이션**을 정의하는 것이었습니다.

`fade_in.xml`은 투명도 0에서 1로 서서히 나타나는 효과,
`scale_up.xml`과 `scale_down.xml`은 크기를 살짝 줄였다가 다시 원래대로 돌아오는 효과입니다.

*[셀 클릭 애니메이션 코드]*

셀을 클릭하면 이렇게 작동합니다.

먼저 `scale_up` 애니메이션으로 살짝 줄어들고,
150ms 후에 `scale_down` 애니메이션으로 다시 커지면서
동시에 `onDateClick`이 실행됩니다.

사용자는 "내가 이걸 눌렀구나"라는 **시각적 피드백**을 즉시 받게 됩니다.

*[DiffUtil 코드]*

RecyclerView는 DiffUtil을 사용해서 변경된 아이템만 자동으로 애니메이션을 적용합니다.
전체를 다시 그리는 게 아니라 바뀐 부분만 업데이트하기 때문에 성능도 좋습니다.

결과적으로 부드러운 화면 전환과 향상된 사용자 경험을 제공합니다.

---

### [슬라이드 9: 클라우드 동기화 아키텍처]

#### 클라우드 동기화 (11:30 - 12:00)

*[4.5 제목 가리키기]*

마지막 고민은 "**어떻게 여러 기기에서 데이터를 공유할까?**"였습니다.

요구사항은 간단했습니다.
로그인 없이 사용하고, 고유 ID로 데이터를 식별하며, 로컬 우선으로 동작해야 합니다.

*[동기화 ID 시스템 코드]*

해결책은 **UUID 기반의 동기화 ID**를 생성하는 것이었습니다.

최초 동기화 시 UUID를 생성하고, 이 ID를 사용자에게 알려줍니다.
다른 기기에서 같은 ID를 입력하면 데이터를 가져올 수 있습니다.

*[REST API 코드]*

REST API는 간단하게 세 가지입니다.
데이터 가져오기, 상태 조회, 데이터 업로드.

*[동기화 플로우 다이어그램]*

전체 플로우는 이렇습니다.
로컬 DB와 Repository가 통신하고, Repository가 Retrofit을 통해 서버 API와 통신합니다.

충돌 해결은 현재 **단순 덮어쓰기** 방식을 사용하고 있습니다.
나중에 수정한 쪽이 이깁니다.
향후에는 타임스탬프 기반 병합을 고려하고 있습니다.

---

## 5부: 아키텍처 (12:00 - 13:00)

### [슬라이드 10: MVVM 패턴]

*[5.1 아키텍처 다이어그램 가리키기]*

전체 아키텍처는 **MVVM 패턴**을 따릅니다.

맨 위에 **View** 계층이 있고, Fragment, Activity, BottomSheet가 여기에 해당합니다.
View는 ViewModel을 **observe**합니다.

중간에 **ViewModel**이 있고, LiveData나 StateFlow로 상태를 관리합니다.
ViewModel은 Repository를 **호출**합니다.

맨 아래 **Repository**가 있고, 데이터 소스를 통합합니다.
로컬 소스는 Room Database, 원격 소스는 Retrofit API입니다.

*[데이터 흐름 설명]*

할일을 추가하는 과정을 예로 들면:

1. AddTaskBottomSheet에서 사용자가 입력
2. ViewModel의 insertTask 호출
3. Repository의 insertTask 호출
4. Room Database에 저장
5. LiveData가 자동으로 업데이트
6. CalendarFragment UI가 자동으로 갱신

이런 단방향 데이터 흐름 덕분에 코드가 명확하고 테스트하기 쉽습니다.

---

## 6부: 배운 점 (13:00 - 15:00)

### [슬라이드 11: 배운 점과 느낀 점]

*[6.1 기술적 성장 부분]*

이 프로젝트를 통해 많은 것을 배웠습니다.

**기술적으로는**,

Kotlin Coroutines와 Flow를 실전에서 활용하면서 비동기 프로그래밍을 확실히 이해했고,
Room Database의 Entity, DAO, Database 설계를 경험했으며,
Material Design 컴포넌트들을 실제로 사용해봤습니다.

*[6.2 디자인 및 UX 부분]*

**디자인 측면에서는**,

글래스모피즘이 단순한 투명도가 아니라 블러 효과가 핵심이라는 것을 깨달았고,
Bottom Sheet 같은 모바일 특화 UI 패턴의 중요성을 이해했으며,
작은 애니메이션이 사용자 경험에 큰 영향을 준다는 것을 배웠습니다.

*[6.3 개발 프로세스 부분]*

**개발 프로세스 측면에서는**,

반복적인 개선이 얼마나 중요한지 느꼈습니다.
초기 노란색 배경에서 파란/보라 그라디언트로 바꾸기까지 여러 번의 시도가 있었고,
작은 indicator에서 테두리 강조로 변경하는 과정도 마찬가지였습니다.

테스트의 중요성도 실감했습니다.
다양한 Android 버전에서 테스트하고, 권한 처리 예외 상황에 대응하며,
네트워크 실패 시나리오를 검증하는 과정이 필수적이었습니다.

*[6.4 어려웠던 점]*

**어려웠던 점**도 있었습니다.

BlurView의 성능 최적화가 가장 힘들었습니다.
처음에는 모든 셀에 BlurView를 넣었더니 렉이 심하게 발생했습니다.
BlurView 개수를 최소화하고 하드웨어 가속을 적절히 활용해서 해결했습니다.

이미지 권한 관리도 복잡했습니다.
Android 버전별로 권한이 다르고, persistable URI permission 개념을 이해하는 데 시간이 걸렸습니다.

*[6.5 개선 방향]*

**앞으로 추가하고 싶은 기능**들입니다.

위젯 지원, 알림 기능, 테마 커스터마이징, 통계 화면, 검색 기능, 태그와 카테고리 등을 고려하고 있습니다.

기술적으로는 단위 테스트와 UI 테스트를 추가하고,
CI/CD 파이프라인을 구축하며,
Firebase Performance로 성능을 모니터링하고 싶습니다.

*[6.6 느낀 점]*

**마지막으로 느낀 점**입니다.

*[첫 번째 인용구]*

> "디자인과 기능의 균형이 중요하다"

처음에는 화려한 디자인에만 집중했지만, 결국 사용자 경험이 더 중요하다는 것을 깨달았습니다.

*[두 번째 인용구]*

> "작은 디테일이 큰 차이를 만든다"

애니메이션, 색상, 간격 같은 작은 요소들이 모여서 전체 완성도를 결정합니다.

*[세 번째 인용구]*

> "오픈소스 커뮤니티의 힘"

훌륭한 라이브러리 덕분에 빠르게 개발할 수 있었고, 저도 오픈소스에 기여하고 싶다는 동기가 생겼습니다.

---

## 마무리 (15:00 - 15:30)

### [슬라이드 12: 마무리]

*[마무리 섹션 가리키기]*

Glasscal 프로젝트를 통해 Android 네이티브 개발의 전반적인 과정을 경험했습니다.

디자인부터 아키텍처, 데이터 관리, 네트워크 통신까지 다양한 영역을 다루며 정말 많은 것을 배웠습니다.

*[잠시 멈춤, 청중과 눈 맞추기]*

앞으로도 사용자에게 진정한 가치를 제공하는 앱을 만들기 위해 계속 학습하고 개선해 나가겠습니다.

여기까지 제 발표였고, 궁금하신 점이나 피드백이 있으시면 언제든지 말씀해 주세요.

경청해 주셔서 감사합니다.

*[발표 종료, 박수 기다리기]*

---

## 질의응답 대비 예상 질문 & 답변

### Q1: "글래스모피즘 디자인의 가독성 문제는 없었나요?"

**A:** 좋은 질문입니다. 초기에는 배경이 너무 화려해서 텍스트 가독성이 떨어지는 문제가 있었습니다.
이를 해결하기 위해:
1. 텍스트에 그림자를 추가했고
2. 배경 불투명도를 조절했으며
3. 충분한 대비(contrast)를 유지하도록 색상을 조정했습니다.
향후에는 고대비 모드도 추가할 계획입니다.

### Q2: "BlurView의 성능 이슈는 어떻게 해결했나요?"

**A:** BlurView는 실시간으로 블러를 계산하기 때문에 성능 비용이 높습니다.
해결 방법:
1. BlurView를 최소한으로 사용 (헤더와 요일 바에만 적용)
2. 캘린더 셀은 정적인 drawable로 처리
3. 하드웨어 가속 활용
4. blurRadius를 적절히 조절 (너무 높으면 렉 발생)
실제 테스트 결과 중급 사양 기기에서도 60fps를 유지했습니다.

### Q3: "동기화 충돌 해결은 어떻게 하나요?"

**A:** 현재는 간단한 "마지막 수정 승리(Last Write Wins)" 전략을 사용합니다.
하지만 이는 임시 방편이고, 향후 개선 계획은:
1. 타임스탬프 기반 병합 (각 할일마다 updatedAt 비교)
2. CRDT(Conflict-free Replicated Data Type) 도입 검토
3. 사용자에게 충돌 상황 알림 및 선택권 제공
실시간 협업이 아니기 때문에 현재 방식으로도 대부분의 경우 문제없습니다.

### Q4: "이 프로젝트에서 가장 어려웠던 부분은?"

**A:** 기술적으로는 BlurView 최적화가 가장 어려웠지만,
개인적으로는 **디자인 결정**이 가장 힘들었습니다.
배경 색상을 수십 번 바꿔보고, 불투명도를 1%씩 조절하며,
"이게 진짜 유리처럼 보이는가?"를 계속 고민했습니다.
기술은 검색하면 답이 나오지만, 디자인 감각은 수많은 시행착오 끝에 얻어진다는 것을 배웠습니다.

### Q5: "상용화 계획은 있나요?"

**A:** 현재는 포트폴리오 목적의 개인 프로젝트지만,
향후 개선 사항을 추가하고 충분히 안정화되면 Play Store에 출시할 계획입니다.
그 전에 해야 할 일:
1. 단위 테스트 및 통합 테스트 작성
2. 접근성 개선 (TalkBack 지원 등)
3. 다국어 지원
4. 성능 최적화 및 메모리 누수 검사
5. 베타 테스터 모집 및 피드백 반영

### Q6: "왜 Jetpack Compose가 아닌 XML을 사용했나요?"

**A:** 이 프로젝트를 시작할 당시 Jetpack Compose를 사용할지 고민했습니다.
XML을 선택한 이유:
1. BlurView 라이브러리가 Compose를 공식 지원하지 않음
2. Material Components와의 호환성
3. XML로도 충분히 아름다운 UI 구현 가능
하지만 다음 프로젝트에서는 Compose를 적극 활용할 계획입니다.

### Q7: "보안 측면은 어떻게 고려했나요?"

**A:** 좋은 지적입니다. 현재 구현에서는:
1. HTTPS 통신 강제 (network_security_config.xml)
2. SQL Injection 방지 (Room이 자동으로 처리)
3. 민감한 정보는 SharedPreferences 대신 EncryptedSharedPreferences 사용 고려
4. ProGuard/R8로 코드 난독화

개선 필요 사항:
1. 동기화 ID에 추가 인증 레이어
2. 전송 데이터 암호화
3. 디바이스별 인증 토큰 추가

---

## 발표 팁

### 자세와 목소리
- **시선**: 청중과 눈 맞추기, 자료만 보지 않기
- **제스처**: 자연스럽게 손동작 활용
- **목소리**: 또렷하고 자신감 있게, 빠르지 않게
- **호흡**: 문장 사이에 잠시 멈추기

### 슬라이드 활용
- **포인터**: 중요한 부분을 가리킬 때만 사용
- **전환**: 자연스럽게, 너무 빠르지 않게
- **코드**: 중요한 부분만 강조, 줄 번호 활용

### 시간 관리
- 전체 15분 목표
- 각 섹션별 시간 체크
- 여유 시간 2-3분 확보

### 긴장 완화
- 발표 전날 충분한 수면
- 발표 전 심호흡
- "잘하려고 하지 말고, 내가 아는 걸 나누자"는 마음가짐

---

## 발표 후 체크리스트

- [ ] 질의응답 메모하기
- [ ] 피드백 수집하기
- [ ] 발표 자료 공유하기 (PDF, GitHub)
- [ ] 개선 사항 정리하기

---

**화이팅! 자신감 있게 발표하세요! 🎉**
